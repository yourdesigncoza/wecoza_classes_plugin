---
phase: 01-database-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - includes/migrations/001_add_class_code_sequence.sql
  - includes/migrations/002_add_class_code_unique_index.sql
  - includes/migrations/003_add_class_code_constraint.sql
autonomous: true

must_haves:
  truths:
    - "PostgreSQL sequence class_code_seq exists and returns incremental values"
    - "Database prevents duplicate class_code values"
    - "Class_code queries use index (sub-100ms performance)"
    - "Concurrent nextval() calls never produce duplicates"
  artifacts:
    - path: "includes/migrations/001_add_class_code_sequence.sql"
      provides: "Sequence creation with START WITH 1001"
      contains: "CREATE SEQUENCE"
    - path: "includes/migrations/002_add_class_code_unique_index.sql"
      provides: "Non-blocking unique index creation"
      contains: "CONCURRENTLY"
    - path: "includes/migrations/003_add_class_code_constraint.sql"
      provides: "Unique constraint using existing index"
      contains: "UNIQUE USING INDEX"
  key_links:
    - from: "class_code_seq"
      to: "classes.class_code"
      via: "OWNED BY relationship"
      pattern: "OWNED BY classes\\.class_code"
    - from: "idx_classes_class_code_unique"
      to: "class_code_unique constraint"
      via: "USING INDEX"
      pattern: "USING INDEX idx_classes_class_code_unique"
---

<objective>
Create PostgreSQL database foundation for race-condition-free sequential class code generation.

Purpose: Enable simple class codes (ABC1234) by providing atomic sequential numbering and uniqueness guarantees at the database level.

Output: Three SQL migration files that create sequence, unique index, and constraint.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-database-foundation/01-RESEARCH.md

Existing infrastructure:
- DatabaseService at app/Services/Database/DatabaseService.php (PDO singleton with transaction support)
- Migration pattern: SQL files in includes/migrations/ executed manually
- Existing index: idx_classes_class_code (B-tree, non-unique) - will be replaced
- Field: classes.class_code VARCHAR(50) with existing beta data
</context>

<tasks>

<task type="auto">
  <name>Task 1: Pre-flight validation and sequence creation</name>
  <files>includes/migrations/001_add_class_code_sequence.sql</files>
  <action>
First, run validation queries via wp-cli or direct database connection to check for duplicates:

```sql
-- Check for duplicates (must return 0 rows)
SELECT class_code, COUNT(*) FROM classes
WHERE class_code IS NOT NULL
GROUP BY class_code HAVING COUNT(*) > 1;

-- Check for NULL/empty values
SELECT COUNT(*) FROM classes WHERE class_code IS NULL OR class_code = '';

-- Get current max sequential number if any codes follow numeric pattern
SELECT MAX(CAST(REGEXP_REPLACE(class_code, '[^0-9]', '', 'g') AS INTEGER))
FROM classes WHERE class_code ~ '[0-9]+';
```

If duplicates exist, STOP and report - business decision needed.

If no duplicates, create migration file `001_add_class_code_sequence.sql`:

```sql
-- Migration 001: Create class_code sequence
-- Purpose: Atomic sequential number generation for class codes
-- Requirement: DB-01, DB-04

-- Create sequence starting at 1001 (preserves space for existing codes)
CREATE SEQUENCE IF NOT EXISTS class_code_seq
    AS bigint
    INCREMENT BY 1
    START WITH 1001
    MINVALUE 1
    NO MAXVALUE
    CACHE 1
    NO CYCLE;

-- Bind sequence lifecycle to the class_code column
-- If column is dropped, sequence is automatically dropped (safety)
ALTER SEQUENCE class_code_seq OWNED BY classes.class_code;

-- Add comment documenting purpose
COMMENT ON SEQUENCE class_code_seq IS 'Sequential number generator for class codes. Format: [PREFIX][NNNN]. Used by ClassCodeService. Lifecycle bound to classes.class_code column.';

-- Test: Verify sequence works
-- SELECT nextval('class_code_seq');  -- Should return 1001
-- SELECT currval('class_code_seq');  -- Should return 1001
```
  </action>
  <verify>
Run via psql or wp-cli:
```bash
# Execute migration
psql -h $DB_HOST -p $DB_PORT -U $DB_USER -d $DB_NAME -f includes/migrations/001_add_class_code_sequence.sql

# Verify sequence exists
psql -c "SELECT sequencename, last_value FROM pg_sequences WHERE sequencename = 'class_code_seq';"

# Verify nextval works
psql -c "SELECT nextval('class_code_seq');"  # Should return 1001

# Verify OWNED BY relationship
psql -c "SELECT pg_get_serial_sequence('classes', 'class_code');"
# Should return 'public.class_code_seq'
```
  </verify>
  <done>Sequence class_code_seq exists, starts at 1001, nextval() returns incrementing values, OWNED BY classes.class_code</done>
</task>

<task type="auto">
  <name>Task 2: Create unique index (non-blocking)</name>
  <files>includes/migrations/002_add_class_code_unique_index.sql</files>
  <action>
Create migration file `002_add_class_code_unique_index.sql`:

```sql
-- Migration 002: Create unique index on class_code (non-blocking)
-- Purpose: Enable uniqueness enforcement without blocking production operations
-- Requirement: DB-02, DB-03
-- Note: CONCURRENTLY cannot run inside transaction block

-- Drop existing non-unique index (if exists) to avoid naming conflicts
DROP INDEX IF EXISTS idx_classes_class_code;

-- Create unique index without blocking writes
-- This takes longer but allows production operations to continue
CREATE UNIQUE INDEX CONCURRENTLY idx_classes_class_code_unique
ON classes (class_code)
WHERE class_code IS NOT NULL AND class_code != '';

-- Verify index is valid (CONCURRENTLY can create invalid index on failure)
-- Run after execution:
-- SELECT indexname, indisvalid FROM pg_indexes JOIN pg_class ON indexname = relname
-- WHERE indexname = 'idx_classes_class_code_unique';
```

IMPORTANT: The CONCURRENTLY option cannot be used inside a transaction block. Run this migration outside of BEGIN/COMMIT.
  </action>
  <verify>
```bash
# Execute migration (note: cannot be in transaction)
psql -h $DB_HOST -p $DB_PORT -U $DB_USER -d $DB_NAME -f includes/migrations/002_add_class_code_unique_index.sql

# Verify index exists and is valid
psql -c "SELECT indexname, indexdef FROM pg_indexes WHERE indexname = 'idx_classes_class_code_unique';"

# Verify index is being used
psql -c "EXPLAIN ANALYZE SELECT * FROM classes WHERE class_code = 'TEST123';"
# Should show "Index Scan using idx_classes_class_code_unique"
```
  </verify>
  <done>Unique index idx_classes_class_code_unique exists, is valid, and query planner uses it</done>
</task>

<task type="auto">
  <name>Task 3: Add unique constraint using index</name>
  <files>includes/migrations/003_add_class_code_constraint.sql</files>
  <action>
Create migration file `003_add_class_code_constraint.sql`:

```sql
-- Migration 003: Add unique constraint using existing index
-- Purpose: Provide named constraint for database-level uniqueness guarantee
-- Requirement: DB-02
-- Note: This requires brief ACCESS EXCLUSIVE lock (~2-5 seconds)

-- Add constraint using the already-built index (no table scan needed)
ALTER TABLE classes
ADD CONSTRAINT class_code_unique
UNIQUE USING INDEX idx_classes_class_code_unique;

-- Add comment documenting constraint purpose
COMMENT ON CONSTRAINT class_code_unique ON classes IS 'Ensures class codes are globally unique. Index built CONCURRENTLY in migration 002.';

-- Verify constraint exists:
-- SELECT conname, contype FROM pg_constraint WHERE conname = 'class_code_unique';
```

This migration takes a brief lock but no table scan since the index already exists.
  </action>
  <verify>
```bash
# Execute migration
psql -h $DB_HOST -p $DB_PORT -U $DB_USER -d $DB_NAME -f includes/migrations/003_add_class_code_constraint.sql

# Verify constraint exists
psql -c "SELECT conname, contype FROM pg_constraint WHERE conname = 'class_code_unique';"
# Should show: class_code_unique | u

# Test constraint enforcement (should fail with duplicate)
psql -c "INSERT INTO classes (class_code) VALUES ('TEST_DUP'); INSERT INTO classes (class_code) VALUES ('TEST_DUP');"
# Second insert should fail with unique constraint violation
```
  </verify>
  <done>Constraint class_code_unique exists and prevents duplicate class_code values</done>
</task>

</tasks>

<verification>
After all tasks complete, verify full database foundation:

1. **Sequence test:**
```sql
SELECT nextval('class_code_seq') AS val1;
SELECT nextval('class_code_seq') AS val2;
-- val2 should be val1 + 1
```

2. **Concurrency test (run in two separate sessions):**
```sql
-- Session 1
SELECT nextval('class_code_seq');
-- Session 2 (simultaneously)
SELECT nextval('class_code_seq');
-- Both should return different values
```

3. **Uniqueness test:**
```sql
INSERT INTO classes (class_code, client_id, class_type) VALUES ('UNIQUE_TEST_123', 1, 'skills');
INSERT INTO classes (class_code, client_id, class_type) VALUES ('UNIQUE_TEST_123', 1, 'skills');
-- Second insert should fail with constraint violation
```

4. **Performance test:**
```sql
EXPLAIN ANALYZE SELECT * FROM classes WHERE class_code = 'UNIQUE_TEST_123';
-- Should show index scan, execution time < 1ms
```

5. **OWNED BY relationship test:**
```sql
SELECT pg_get_serial_sequence('classes', 'class_code');
-- Should return 'public.class_code_seq'
```

6. **Cleanup test data:**
```sql
DELETE FROM classes WHERE class_code LIKE 'UNIQUE_TEST%' OR class_code LIKE 'TEST%';
SELECT setval('class_code_seq', 1000);  -- Reset to 1000, next will be 1001
```
</verification>

<success_criteria>
1. Sequence class_code_seq exists and increments atomically
2. Sequence is OWNED BY classes.class_code (lifecycle bound)
3. Unique constraint class_code_unique prevents duplicates
4. Index idx_classes_class_code_unique provides sub-millisecond lookups
5. Concurrent sequence calls return unique values
6. Existing beta data preserved unchanged
7. Three migration files created in includes/migrations/
</success_criteria>

<output>
After completion, create `.planning/phases/01-database-foundation/01-01-SUMMARY.md`
</output>
